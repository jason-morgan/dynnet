##' Converts a matrix of latent locations to a vector of pairwise distances.
##'
##' Converts a matrix of latent locations for each of the \code{n} nodes to a
##' column vector of pairwise distances.
##' @title Convert Latent Locations to a Vector of Distances
##' @param Z Matrix representing latent locations.
##' @param ... Additional parameters to be passed to \code{\link{dist}}.
##' @return Column vector of distances as contained in the \code{lower.tri(d)},
##' where \code{d} is the distance matrix.
##' @author Jason W. Morgan \email{jason.w.morgan@@gmail.com}
as_distance_vector <- function(Z, ...)
{
    matrix(dist(Z, ...))
}

##' Calculate node positions for a specific time period.
##'
##' Calculate node positions for a specific time period.
##' @title Calculate Node Postitions
##' @param periods Integer vector of time periods for which to calculate the
##' position.
##' @param pos Matrix of latent locations.
##' @param traj Matrix of trajectories.
##' @param fn Function taking a time period, latent starting positions, and
##' trajectories, which returns a matrix of latent position. Default is the
##' simple linear trajectory model.
##' @param ... List of parameters to pass to the trajectory function.
##' @return List of latent locations, one for each time period.
##' @author Jason W. Morgan \email{jason.w.morgan@@gmail.com}
calc_positions <- function(periods, pos, traj, fn=trajectory_linear, ...)
{
    lapply(periods, fn, pos, traj, ...)
}

##' Checks whether all elements of the supplied list are equal.
##'
##' Checks whether all elements of the supplied list are equal.
##' @title Check if All List Elements are Equal
##' @param lst List.
##' @return Logical indicating whether or not all values of the list are equal.
##' @author Jason W. Morgan \email{jason.w.morgan@@gmail.com}
list_all_equal <- function(lst)
{
    length(unique(lst)) == 1
}

##' Select a random point from a k-dimensional unit hypersphere.
##'
##' Select a random point from a k-dimensional unit hypersphere.
##' @title Random Point From \code{k}-dimensional Unit Hypersphere
##' @param k Positive integer indicating the dimensions of the hypersphere.
##' @return Numeric vector of coordinates.
##' @author Jason W. Morgan \email{jason.w.morgan@@gmail.com}
rksphere <- function(k)
{
    x <- rnorm(k)
    (1 / sqrt(x %*% x)) * x
}

## ## Takes a path object as generated by generate_path_data() and returns the
## ## adjacency matrix for network realization in time T.
## as_adjacency <- function(net, T=1)
## {
##     n <- net$stan$n
##     N <- n * (n-1) / 2

##     idx <- 1+(T-1)*N
##     adj <- matrix(0, nrow=n, ncol=n)
##     adj[lower.tri(adj)] <- net$stan$y[idx:(idx+N-1)]
##     adj
## }

## to_columns <- function(net, coef, center=FALSE)
## {
##     b0 <- coef[1]
##     if (net$stan$K == 1) {
##         span <- net$stan$n - 2
##         pos  <- matrix(coef[2:(span+1)], ncol=1)
##         traj <- matrix(coef[(span+2):length(coef)], ncol=1)

##         pos  <- rbind(c(-1.0), c(1.0), pos)
##         traj <- rbind(c( 0.0), c(0.0), traj)

##         if (isTRUE(center)) {
##             pos  <- scale(pos, scale=FALSE)
##         }
##     } else {
##         span <- net$stan$n - 3
##         pos  <- coef[2:(2*span+1)]
##         traj <- coef[(2*span+2):length(coef)]
##         pos  <- matrix(pos, ncol=2)
##         traj <- matrix(traj, ncol=2)

##         pos  <- rbind(c(0.0, 1.0), c(-1.0, -1.0), c(1.0,-1.0), pos)
##         traj <- rbind(c(0.0, 0.0), c( 0.0,  0.0), c(0.0, 0.0), traj)

##         if (isTRUE(center)) {
##             pos  <- scale(pos, scale=FALSE)
##         }
##     }

##     list(b0=b0, pos=pos, traj=traj)
## }
